package org.builder.session.jackson.workflow.utilize;

import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicLong;

import org.build.session.jackson.proto.Unit;
import org.builder.session.jackson.client.ecs.TaskMetadataClient;
import org.builder.session.jackson.system.DigitalUnit;
import org.builder.session.jackson.system.SystemUtil;

import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Range;

import lombok.Getter;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class CpuConsumer extends AbstractPidConsumer {

    private static final DigitalUnit BASE_UNIT = DigitalUnit.VCPU;
    private static final double DEFAULT_INITIAL_TARGET = 0.33;
    private static final Duration PERIOD =
            Duration.ofMillis(Integer.parseInt(System.getenv("CONSUMER_CPU_PERIOD_IN_MILLIS")));
    private static final Comparator<AtomicLong> SMALLEST_TO_LARGEST = Comparator.comparingLong(a -> a.get());
    private static final Comparator<AtomicLong> LARGEST_TO_SMALLEST = SMALLEST_TO_LARGEST.reversed();

    @Getter
    private final String name = "CpuConsumer";
    @NonNull
    private final SystemUtil system;
    @NonNull
    private final ExecutorService executorService;
    @NonNull
    private final ImmutableMap<Unit, Double> max;
    @NonNull
    private final List<AtomicLong> workloads;
    @NonNull
    private final AtomicLong scaleAdjustment = new AtomicLong(0);
    @Getter
    private double targetPercentage;

    public CpuConsumer(@NonNull final SystemUtil system,
                          @NonNull final PIDConfig pidConfig) {
        this(DEFAULT_INITIAL_TARGET, system, pidConfig);
    }

    public CpuConsumer(double targetPercentage,
                       @NonNull SystemUtil system,
                       @NonNull PIDConfig pidConfig) {
        super(pidConfig);
        final long hostProcessorCount = TaskMetadataClient.createContainerStatsClient(Duration.ofMillis(1))
                                                          .call()
                                                          .getCpuStats()
                                                          .getOnlineCpus();
        Preconditions.checkArgument(0.0 <= targetPercentage && targetPercentage <= 1.0, "Must be between 0.0 and 1.0.");
        Preconditions.checkArgument(hostProcessorCount > 0, "Processor count must be positive.");
        this.targetPercentage = targetPercentage;
        this.system = system;
        this.max = ImmutableMap.<Unit, Double>builder().put(Unit.PERCENTAGE, 1.0)
                                            .put(Unit.VCPU, (double)this.system.getTotalCpu(DigitalUnit.VCPU))
                                            .build();

        /**
         * To consume CPU, we have two slightly complex components. For each processor,
         * there is a ratio BUSY/TOTAL_TIME which designates the CPU "load" that we wish
         * to target. If multiple processors are on the CPU, the load is an average of those
         * percentages (assuming equally paced processors).
         *
         * "Free" time can be generated by sleeping a thread and "Busy" time can be computed
         * by running some rapid computation (like checking whether you should still be busy).
         * The simplest approach would be to Thread.sleep(Free) and loop a busy check for the
         * Busy cycle. Gradually decreasing or increasing the busy/free times will change the
         * CPU usage. However, this actually has odd results because we are dealing with
         * fractions.
         *
         * FREE/BUSY (UTIL%) => 1/4 (80%) => 1/3 (66%) => 1/2 (33%) => 1/1 (50%)
         *
         * Using Thread.sleep(Nanos) produces strange results when the OS/JVM doesn't handle nanos
         * correctly. Additionally, launching a large number of workers each doing 1/1000 work
         * has a lot of memory overhead which results in a poor end result for other Consumers.
         * Instead, we will proceed with the following concept.
         *
         * - We aim to optimize by seconds, this will give us roughly 1/(1000*PROCESSOR) precision.
         * - Each Worker begins with essentially infinite sleep time in 1 second period: 1000/0
         * - When scale comes in, we have to intelligently convert and assign load that would
         *   make sense for the scale provided to one of the processors.
         *
         * How do we convert between SCALE (seemingly-arbitrary PID value based on PID config)
         * and assignment? Assume SCALE=BUSY time. Then we always start with the first thread
         * and move down the line when removing or adding scale. This addition and removal can
         * be done by a single additional background thread.
         */
        this.executorService = Executors.newFixedThreadPool((int)hostProcessorCount + 1);
        this.workloads = new ArrayList<>();

        // Start the consuming threads...
        for(int i = 0; i < hostProcessorCount; i++) {
            final AtomicLong workload = new AtomicLong();
            this.workloads.add(workload);
            this.executorService.submit(() -> {
                while(true) {
                    try {
                        Instant start = Instant.now();
                        long workTimeInMillis = workload.get();
                        long sleepTimeInMillis = PERIOD.toMillis() - workload.get();
                        // The ratio of work to sleep time should be the CPU on this processor.
                        while (Duration.between(start, Instant.now()).toMillis() < workTimeInMillis) { }
                        if(sleepTimeInMillis > 0) {
                            Thread.sleep(sleepTimeInMillis);
                        }
                    } catch (Throwable t) {
                        log.warn("Ran into exception in CPU consumption thread.", t);
                    }
                }
            });
        }

        // Start the applier/adjustment thread...
        executorService.submit(() -> {
            while(true) {
                try {
                    long adjustment = scaleAdjustment.get();
                    scaleAdjustment.addAndGet(-adjustment);
                    //Sort to maintain ordering...
                    Collections.sort(workloads, LARGEST_TO_SMALLEST);
                    if(adjustment >= 0) {
                        for(AtomicLong work : workloads) {
                            if(adjustment <= 0) {
                                break;
                            } else {
                                // We can adjust as long as the current adjustment is enough and there is space.
                                while (work.get() < PERIOD.toMillis() && adjustment - work.get() >= 0) {
                                    //Increment work for this thread and reduce adjustment equivalently.
                                    adjustment -= work.getAndIncrement();
                                }
                            }
                        }
                    } else {
                        for(AtomicLong work : workloads) {
                            if(adjustment >= 0) {
                                break;
                            } else {
                                // We can adjust as long as the current adjustment is enough and there is space.
                                while (work.get() > 0 && work.get() + adjustment <= 0) {
                                    //Decrement work for this thread and reduce adjustment equivalently.
                                    adjustment += work.getAndDecrement();
                                }
                            }
                        }
                    }

                    // Add the remainder value back in.
                    scaleAdjustment.addAndGet(adjustment);
                    log.debug("Workloads distributed (Remainder: {}): {}", adjustment, workloads);
                    Thread.sleep(getRunDelay().toMillis());
                } catch (Throwable t) {
                    log.warn("Swallowing exception caught in CPUConsumer adjustment thread.", t);
                }
            }
        });
    }

    @Override
    public void setTarget (double value, @NonNull Unit unit) {
        boolean isPercentage = DigitalUnit.isPercentage(unit);
        Preconditions.checkArgument(isPercentage || BASE_UNIT.canConvertTo(DigitalUnit.from(unit)),
                                    "Must specify a compute unit, but got " + unit);
        Preconditions.checkArgument(Range.open(0.0, max.get(unit)).contains(value),
                                    "Must specify a value in max (0.0, " + max.get(unit) + "), but got " + unit);
        log.info("Setting CPU consumption from " + this.targetPercentage + " to " + value + " at " + unit.name());
        this.targetPercentage = value / max.get(unit);
    }

    @Override
    public double getTarget (Unit unit) {
        boolean isPercentage = DigitalUnit.isPercentage(unit);
        Preconditions.checkArgument(isPercentage || BASE_UNIT.canConvertTo(DigitalUnit.from(unit)),
                                    "Must specify a compute unit, but got " + unit);
        return isPercentage ? this.getTargetPercentage()
                            : DigitalUnit.from(unit).from(getGoal(), DigitalUnit.VCPU);
    }

    @Override
    public double getActual (Unit unit) {
        return DigitalUnit.isPercentage(unit) ? this.system.getCpuPercentage()
                                              : this.system.getUsedCpu(DigitalUnit.from(unit));
    }

    @Override
    protected long getGoal () {
        return (long)(this.system.getTotalCpu(DigitalUnit.VCPU) * this.getTargetPercentage());
    }

    @Override
    protected long getConsumed () {
        return this.system.getUsedCpu(DigitalUnit.VCPU);
    }

    @Override
    protected void generateLoad (long scale) {
        Preconditions.checkArgument(scale >= 0, "Scale should be greater than or equal to zero.");
        scaleAdjustment.addAndGet(scale);
    }

    @Override
    protected void destroyLoad (long scale) {
        Preconditions.checkArgument(scale >= 0, "Scale should be greater than or equal to zero.");
        scaleAdjustment.addAndGet(-scale);
    }

    @Override
    public void close() {
        executorService.shutdown();
        super.close();
    }
}
